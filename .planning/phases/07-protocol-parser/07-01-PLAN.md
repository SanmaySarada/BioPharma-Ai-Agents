---
phase: 07-protocol-parser
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/omni_agents/llm/response_parser.py
  - src/omni_agents/llm/__init__.py
  - src/omni_agents/agents/docx_reader.py
  - src/omni_agents/config.py
  - tests/test_llm/test_response_parser.py
  - tests/test_pipeline/test_protocol_extraction.py
autonomous: true

must_haves:
  truths:
    - "extract_json() reliably extracts JSON from LLM responses with fenced blocks, bare JSON, and mixed text"
    - "extract_protocol_text() reads all content from .docx files including paragraphs and tables"
    - "ProtocolExtraction model has all TrialConfig fields as Optional[T] = None"
    - "merge_extraction() correctly overlays extracted values onto TrialConfig defaults and reports which fields used defaults"
  artifacts:
    - path: "src/omni_agents/llm/response_parser.py"
      provides: "extract_json() function"
      contains: "def extract_json"
    - path: "src/omni_agents/agents/docx_reader.py"
      provides: "extract_protocol_text() function"
      contains: "def extract_protocol_text"
    - path: "src/omni_agents/config.py"
      provides: "ProtocolExtraction model and merge_extraction()"
      contains: "class ProtocolExtraction"
    - path: "tests/test_llm/test_response_parser.py"
      provides: "Tests for extract_json()"
      contains: "class TestExtractJson"
    - path: "tests/test_pipeline/test_protocol_extraction.py"
      provides: "Tests for ProtocolExtraction model and merge logic"
      contains: "class TestMergeExtraction"
  key_links:
    - from: "src/omni_agents/config.py"
      to: "ProtocolExtraction -> TrialConfig"
      via: "merge_extraction() overlays non-None fields"
      pattern: "model_copy\\(update="
    - from: "src/omni_agents/agents/docx_reader.py"
      to: "python-docx Document"
      via: "doc.paragraphs + doc.tables iteration"
      pattern: "from docx import Document"
---

<objective>
Build the three foundation utilities that the Protocol Parser Agent depends on: (1) a JSON extractor for LLM responses, (2) a .docx text extractor that captures paragraphs AND tables, and (3) the ProtocolExtraction Pydantic model with merge logic that tracks which fields were extracted vs defaulted.

Purpose: These utilities are the building blocks for the Protocol Parser Agent. They must be solid and well-tested because silent misextraction (PITFALL-01) and missing table data (PITFALL-05) are the highest-risk failure modes.

Output: Four source files (response_parser.py updated, docx_reader.py new, config.py updated) and two test files.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/research/PITFALLS.md (PITFALL-01, PITFALL-04, PITFALL-05)
@.planning/research/STACK.md (ProtocolExtraction pattern, python-docx usage)
@.planning/research/ARCHITECTURE.md (Feature 1 data flow, component boundaries)

@src/omni_agents/llm/response_parser.py (existing extract_r_code -- model the new extract_json on this pattern)
@src/omni_agents/llm/__init__.py (add extract_json to __all__)
@src/omni_agents/config.py (TrialConfig model -- 14 fields to mirror in ProtocolExtraction)
@tests/test_llm/test_response_parser.py (test pattern to follow for extract_json tests)
@tests/conftest.py (existing test fixtures)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add extract_json() to response_parser.py and create extract_protocol_text() in docx_reader.py</name>
  <files>
    src/omni_agents/llm/response_parser.py
    src/omni_agents/llm/__init__.py
    src/omni_agents/agents/docx_reader.py
    tests/test_llm/test_response_parser.py
  </files>
  <action>
**1a. Add `extract_json()` to `src/omni_agents/llm/response_parser.py`:**

Add a new function below the existing `extract_r_code()`. This extracts a JSON object from LLM responses that may wrap JSON in markdown fences.

```python
_JSON_BLOCK_RE = re.compile(r"```(?:json)?[^\S\n]*\n(.*?)\n```", re.DOTALL)

def extract_json(response_text: str) -> dict | None:
    """Extract a JSON object from an LLM response.

    Handles:
    1. JSON inside ```json ... ``` fenced blocks
    2. JSON inside untagged ``` ... ``` blocks
    3. Bare JSON object (starts with {)
    4. Returns None if no valid JSON found

    Args:
        response_text: Raw text from LLM.

    Returns:
        Parsed dict, or None if no JSON found.
    """
```

Implementation logic:
- First try fenced blocks via `_JSON_BLOCK_RE.findall(response_text)`. For each match, try `json.loads()`. Return first valid dict.
- If no fenced JSON, try finding a bare JSON object: scan for first `{` and last `}`, extract substring, try `json.loads()`.
- Return `None` if nothing parses.
- Import `json` at the top of the file.

**1b. Update `src/omni_agents/llm/__init__.py`:**

Add `extract_json` to the imports and `__all__` list alongside existing `extract_r_code`.

**1c. Create `src/omni_agents/agents/docx_reader.py`:**

New module for .docx text extraction. This addresses PITFALL-05 (tables missed by naive paragraph iteration).

```python
"""Protocol document text extraction from .docx files.

Extracts both paragraphs and table content, preserving structural
markers (headings, table boundaries) so the LLM can understand
document organization.
"""
from pathlib import Path
from docx import Document


def extract_protocol_text(docx_path: Path) -> str:
    """Extract all text from a .docx protocol document.

    Iterates document body elements in order, handling both
    paragraphs and tables. Headings are marked with ## prefix.
    Table rows are pipe-delimited. This addresses PITFALL-05:
    python-docx paragraphs alone miss table content.

    Args:
        docx_path: Path to the .docx file.

    Returns:
        Full document text with structural markers.

    Raises:
        FileNotFoundError: If docx_path does not exist.
        ValueError: If file is not a valid .docx.
    """
```

Implementation:
- Open with `Document(str(docx_path))`
- Iterate `doc.element.body` children to preserve document order
- For paragraph elements (tag ends with `}p`): extract text, prefix headings (style name contains "Heading") with `## `
- For table elements (tag ends with `}tbl`): iterate rows, join cell text with ` | `, prefix each row with `| `
- Skip empty paragraphs (whitespace only)
- Join all parts with `\n`
- Add a helper `_table_to_text(table) -> str` that converts a table to pipe-delimited rows

**1d. Add tests for extract_json() to `tests/test_llm/test_response_parser.py`:**

Add a new test class `TestExtractJson` following the existing test pattern in this file. Test cases:

- `test_json_in_fenced_block`: `"```json\n{\"n_subjects\": 300}\n```"` -> `{"n_subjects": 300}`
- `test_json_in_untagged_block`: `"```\n{\"key\": \"value\"}\n```"` -> `{"key": "value"}`
- `test_bare_json_object`: `"Here is the data: {\"x\": 1, \"y\": 2} hope that helps"` -> `{"x": 1, "y": 2}`
- `test_json_with_surrounding_text`: LLM response with explanation before/after fenced JSON
- `test_nested_json`: JSON with nested objects/arrays
- `test_no_json_returns_none`: Plain text with no JSON -> `None`
- `test_empty_string_returns_none`: `""` -> `None`
- `test_invalid_json_in_fence_returns_none`: Malformed JSON inside fences -> `None`
- `test_multiple_json_blocks_returns_first`: Two fenced JSON blocks -> returns first valid one

Import `extract_json` from `omni_agents.llm.response_parser`.
  </action>
  <verify>
Run `pytest tests/test_llm/test_response_parser.py -v` -- all existing tests pass AND all new TestExtractJson tests pass.
Run `python -c "from omni_agents.llm import extract_json; print(extract_json.__doc__)"` -- import works.
Run `python -c "from omni_agents.agents.docx_reader import extract_protocol_text; print(extract_protocol_text.__doc__)"` -- import works.
  </verify>
  <done>
extract_json() handles fenced JSON, bare JSON, and returns None for non-JSON. extract_protocol_text() reads both paragraphs and tables from .docx files. All tests pass including 9+ new extract_json tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProtocolExtraction model and merge_extraction() with tests</name>
  <files>
    src/omni_agents/config.py
    tests/test_pipeline/test_protocol_extraction.py
  </files>
  <action>
**2a. Add `ProtocolExtraction` model and `merge_extraction()` to `src/omni_agents/config.py`:**

Add BELOW the existing `TrialConfig` class (do NOT modify TrialConfig itself):

```python
class ProtocolExtraction(BaseModel):
    """LLM extraction result. None means 'not found in document'.

    Every field mirrors TrialConfig but is Optional with None default.
    This lets us distinguish 'extracted value' from 'LLM did not find it'
    (PITFALL-04: defaults silently fill gaps).
    """
    n_subjects: int | None = None
    randomization_ratio: str | None = None
    seed: int | None = None
    visits: int | None = None
    endpoint: str | None = None
    treatment_sbp_mean: float | None = None
    treatment_sbp_sd: float | None = None
    placebo_sbp_mean: float | None = None
    placebo_sbp_sd: float | None = None
    baseline_sbp_mean: float | None = None
    baseline_sbp_sd: float | None = None
    age_mean: float | None = None
    age_sd: float | None = None
    missing_rate: float | None = None
    dropout_rate: float | None = None


class ExtractionResult(BaseModel):
    """Result of merging extraction with defaults.

    Tracks which fields came from the document vs TrialConfig defaults.
    """
    config: TrialConfig
    extracted_fields: list[str]   # field names found in document
    defaulted_fields: list[str]   # field names that fell back to defaults


def merge_extraction(
    extraction: ProtocolExtraction,
    defaults: TrialConfig | None = None,
) -> ExtractionResult:
    """Merge LLM extraction with TrialConfig defaults.

    For each ProtocolExtraction field:
    - If not None: use extracted value, record in extracted_fields
    - If None: use TrialConfig default, record in defaulted_fields

    The 'seed' field is always treated as defaulted (not a protocol parameter).

    Args:
        extraction: LLM extraction result with Optional fields.
        defaults: Base TrialConfig to fill gaps. Uses TrialConfig() if None.

    Returns:
        ExtractionResult with merged config and field tracking.
    """
```

Implementation:
- Use `defaults or TrialConfig()` for base values
- Iterate `ProtocolExtraction.model_fields` keys
- Skip `seed` (always default -- it's a simulation parameter, not a protocol parameter)
- For each field: if `getattr(extraction, field) is not None`, add to overrides dict and extracted_fields list; else add to defaulted_fields list
- Build final config: `defaults.model_copy(update=overrides)`
- Return `ExtractionResult(config=final, extracted_fields=extracted, defaulted_fields=defaulted)`

**2b. Create `tests/test_pipeline/test_protocol_extraction.py`:**

```python
"""Tests for ProtocolExtraction model and merge logic."""
import pytest
from omni_agents.config import (
    ExtractionResult,
    ProtocolExtraction,
    TrialConfig,
    merge_extraction,
)
```

Test classes:

**`TestProtocolExtraction`:**
- `test_all_none_by_default`: `ProtocolExtraction()` has all fields None
- `test_partial_extraction`: Setting some fields leaves others None
- `test_field_parity_with_trial_config`: All TrialConfig field names (except those intentionally excluded) exist in ProtocolExtraction

**`TestMergeExtraction`:**
- `test_full_extraction_no_defaults`: All fields extracted -> defaulted_fields is empty (except seed)
- `test_empty_extraction_all_defaults`: No fields extracted -> all in defaulted_fields, config equals TrialConfig()
- `test_partial_extraction_mixed`: Some extracted, some defaulted -> correct split
- `test_extracted_values_override_defaults`: extraction.n_subjects=500 -> result.config.n_subjects == 500
- `test_default_values_preserved`: Non-extracted fields use TrialConfig() defaults
- `test_seed_always_defaulted`: Even if extraction.seed is set, it should be treated as extracted (actually seed IS extractable -- rethink: seed is in the model, so if the LLM sets it, use it. But seed is typically not in a protocol document. Just treat it like any other field.)
- `test_custom_defaults`: Pass a non-default TrialConfig as defaults -> non-extracted fields use THOSE defaults
- `test_extraction_result_fields_complete`: extracted_fields + defaulted_fields covers all TrialConfig fields

Run: `pytest tests/test_pipeline/test_protocol_extraction.py -v`
  </action>
  <verify>
Run `pytest tests/test_pipeline/test_protocol_extraction.py -v` -- all tests pass.
Run `pytest tests/ -v` -- all existing tests still pass (no regressions in config.py changes).
Run `python -c "from omni_agents.config import ProtocolExtraction, merge_extraction; print('OK')"` -- imports work.
  </verify>
  <done>
ProtocolExtraction model mirrors TrialConfig with all Optional fields. merge_extraction() correctly overlays extracted values, preserves defaults for missing fields, and returns ExtractionResult with extracted_fields/defaulted_fields tracking. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_llm/test_response_parser.py -v` -- all extract_json tests pass
2. `pytest tests/test_pipeline/test_protocol_extraction.py -v` -- all merge tests pass
3. `pytest tests/ -v` -- full suite passes, no regressions
4. `python -c "from omni_agents.llm import extract_json"` -- export works
5. `python -c "from omni_agents.config import ProtocolExtraction, ExtractionResult, merge_extraction"` -- exports work
6. `python -c "from omni_agents.agents.docx_reader import extract_protocol_text"` -- import works
</verification>

<success_criteria>
- extract_json() handles fenced JSON, bare JSON, and edge cases with 9+ test cases passing
- extract_protocol_text() reads .docx paragraphs AND tables (PITFALL-05 addressed)
- ProtocolExtraction has all 14 TrialConfig fields as Optional[T] = None
- merge_extraction() returns ExtractionResult with correct extracted/defaulted field tracking
- All 117+ existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-protocol-parser/07-01-SUMMARY.md`
</output>
