---
phase: 01-symmetric-double-programming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/omni_agents/models/resolution.py
  - src/omni_agents/models/consensus.py
  - src/omni_agents/config.py
  - src/omni_agents/pipeline/script_cache.py
autonomous: true

must_haves:
  truths:
    - "TrackResult, StageComparison, ResolutionHint, and ResolutionResult models exist and are importable"
    - "StageComparison model can represent per-stage comparison results with issues list"
    - "ResolutionHint produces structured prompt text via to_prompt_text()"
    - "ResolutionConfig has max_iterations=2, enabled=True defaults"
    - "ScriptCache.cache_key accepts track_id parameter preventing cross-track collisions"
  artifacts:
    - path: "src/omni_agents/models/resolution.py"
      provides: "TrackResult, StageComparison, ResolutionHint, ResolutionResult Pydantic models"
      exports: ["TrackResult", "StageComparison", "ResolutionHint", "ResolutionResult"]
    - path: "src/omni_agents/models/consensus.py"
      provides: "Updated consensus models (unchanged exports, same interface)"
      exports: ["Verdict", "MetricComparison", "ConsensusVerdict"]
    - path: "src/omni_agents/config.py"
      provides: "ResolutionConfig nested model added to Settings"
      contains: "class ResolutionConfig"
    - path: "src/omni_agents/pipeline/script_cache.py"
      provides: "Track-aware cache key computation"
      contains: "track_id"
  key_links:
    - from: "src/omni_agents/models/resolution.py"
      to: "src/omni_agents/models/consensus.py"
      via: "imports Verdict enum"
      pattern: "from omni_agents.models.consensus import Verdict"
    - from: "src/omni_agents/config.py"
      to: "src/omni_agents/models/resolution.py"
      via: "ResolutionConfig referenced by Settings"
      pattern: "resolution.*ResolutionConfig"
---

<objective>
Create the foundational Pydantic models and configuration for the symmetric double programming architecture.

Purpose: All downstream plans (StageComparator, ResolutionLoop, Orchestrator refactor) depend on these data models. This plan establishes the type contracts that enable parallel development of Plans 02 and 03.

Output: New `models/resolution.py` with TrackResult, StageComparison, ResolutionHint, ResolutionResult; updated `config.py` with ResolutionConfig; updated `script_cache.py` with track_id in cache key.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-symmetric-double-programming/01-RESEARCH.md

@src/omni_agents/models/consensus.py
@src/omni_agents/models/execution.py
@src/omni_agents/models/pipeline.py
@src/omni_agents/config.py
@src/omni_agents/pipeline/script_cache.py
@tests/test_pipeline/test_script_cache.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resolution models and update config</name>
  <files>
    src/omni_agents/models/resolution.py
    src/omni_agents/config.py
  </files>
  <action>
Create `src/omni_agents/models/resolution.py` with these Pydantic v2 models (follow the style of existing models in `models/consensus.py` and `models/execution.py` -- BaseModel, type annotations, docstrings):

1. **TrackResult(BaseModel)** -- result of running one full track pipeline:
   - `track_id: str` -- "track_a" or "track_b"
   - `sdtm_dir: Path` -- path to SDTM output directory
   - `adam_dir: Path` -- path to ADaM output directory
   - `stats_dir: Path` -- path to Stats output directory
   - `results_path: Path` -- path to results.json
   - Import Path from pathlib.

2. **StageComparison(BaseModel)** -- result of comparing one stage between tracks:
   - `stage: str` -- "sdtm", "adam", or "stats"
   - `matches: bool` -- True if all checks pass
   - `issues: list[str]` -- human-readable list of discrepancies (empty if matches)
   - `track_a_summary: dict[str, object]` -- summary stats from track A (e.g., {"dm_rows": 300, "vs_rows": 7800})
   - `track_b_summary: dict[str, object]` -- summary stats from track B

3. **StageComparisonResult(BaseModel)** -- aggregated result of all stage comparisons:
   - `comparisons: list[StageComparison]` -- one per stage
   - `@property has_disagreement -> bool` -- True if any comparison.matches is False
   - `@property first_disagreement -> StageComparison | None` -- first stage with matches=False, or None

4. **ResolutionHint(BaseModel)** -- structured hint for a track that needs re-derivation:
   - `stage: str` -- "sdtm", "adam", or "stats"
   - `discrepancies: list[str]` -- what disagrees
   - `validation_failures: list[str]` -- schema/referential integrity failures
   - `suggested_checks: list[str]` -- specific things to verify in code
   - `def to_prompt_text(self) -> str` method that renders a structured text block:
     ```
     RESOLUTION HINT: Your previous {stage} output had discrepancies with an independent validation.

     Discrepancies found:
       - {each discrepancy}

     Validation failures:
       - {each failure}  (only if non-empty)

     Please check:
       - {each suggested check}
     ```

5. **ResolutionResult(BaseModel)** -- outcome of the resolution loop:
   - `resolved: bool` -- True if tracks now agree
   - `iterations: int` -- how many resolution iterations were performed
   - `winning_track: str | None` -- if not resolved, which track was picked (or None if HALT)
   - `stage: str` -- which stage was being resolved
   - `resolution_log: list[str]` -- human-readable log of resolution steps

Add module docstring: "Resolution state models for symmetric double programming architecture."

Update `src/omni_agents/config.py`:

1. Add `ResolutionConfig(BaseModel)` class:
   - `enabled: bool = True` -- whether to attempt resolution on disagreement
   - `max_iterations: int = 2` -- max resolution retry iterations

2. Add `resolution: ResolutionConfig = ResolutionConfig()` field to the `Settings` class.

This is a backward-compatible addition -- existing YAML configs without a `resolution` key will use defaults.
  </action>
  <verify>
Run: `cd /Users/sanmaysarada/omni-ai-agents && python -c "from omni_agents.models.resolution import TrackResult, StageComparison, StageComparisonResult, ResolutionHint, ResolutionResult; from omni_agents.config import Settings, ResolutionConfig; print('All models importable'); s = ResolutionConfig(); print(f'defaults: enabled={s.enabled}, max_iter={s.max_iterations}'); h = ResolutionHint(stage='sdtm', discrepancies=['DM row count: A=298, B=300'], validation_failures=[], suggested_checks=['Check dedup logic']); print(h.to_prompt_text()[:80])"`
  </verify>
  <done>All 5 resolution models importable with correct fields. ResolutionConfig defaults to enabled=True, max_iterations=2. ResolutionHint.to_prompt_text() produces structured text. Settings accepts optional resolution config.</done>
</task>

<task type="auto">
  <name>Task 2: Add track_id to ScriptCache key and update tests</name>
  <files>
    src/omni_agents/pipeline/script_cache.py
    tests/test_pipeline/test_script_cache.py
  </files>
  <action>
Update `ScriptCache.cache_key()` in `src/omni_agents/pipeline/script_cache.py`:

1. Add `track_id: str = ""` parameter (default empty string for backward compat with Simulator which has no track):
   ```python
   @staticmethod
   def cache_key(trial_config: TrialConfig, agent_name: str, track_id: str = "") -> str:
   ```

2. Include track_id in the hash payload:
   ```python
   payload = trial_config.model_dump_json() + "|" + agent_name + "|" + track_id
   ```

3. Update the docstring to document the new parameter.

Update `tests/test_pipeline/test_script_cache.py`:

1. Add a new test `test_cache_key_differs_on_track_id`:
   ```python
   def test_cache_key_differs_on_track_id(self):
       """Same config + agent but different track_id produces different keys."""
       config = TrialConfig()
       key_a = ScriptCache.cache_key(config, "sdtm", "track_a")
       key_b = ScriptCache.cache_key(config, "sdtm", "track_b")
       assert key_a != key_b
   ```

2. Add a test `test_cache_key_backward_compat`:
   ```python
   def test_cache_key_backward_compat(self):
       """Omitting track_id produces same key as before (empty string default)."""
       config = TrialConfig()
       key_no_track = ScriptCache.cache_key(config, "simulator")
       key_empty_track = ScriptCache.cache_key(config, "simulator", "")
       assert key_no_track == key_empty_track
   ```

3. Verify all existing tests still pass (they use the 2-arg form which is still valid).
  </action>
  <verify>
Run: `cd /Users/sanmaysarada/omni-ai-agents && python -m pytest tests/test_pipeline/test_script_cache.py -v`
  </verify>
  <done>All 7 ScriptCache tests pass (5 existing + 2 new). cache_key() accepts optional track_id parameter. Different track_ids produce different keys. Backward compatibility preserved for 2-argument calls.</done>
</task>

</tasks>

<verification>
1. `python -c "from omni_agents.models.resolution import *"` -- all models importable
2. `python -c "from omni_agents.config import Settings; s = Settings.model_json_schema(); assert 'resolution' in str(s)"` -- config schema includes resolution
3. `python -m pytest tests/test_pipeline/test_script_cache.py -v` -- all cache tests pass
4. `python -m pytest tests/ -v` -- no regressions in existing tests
</verification>

<success_criteria>
- models/resolution.py exists with TrackResult, StageComparison, StageComparisonResult, ResolutionHint, ResolutionResult
- ResolutionHint.to_prompt_text() returns structured text
- config.py has ResolutionConfig with enabled=True, max_iterations=2 defaults
- Settings accepts optional resolution block in YAML
- ScriptCache.cache_key accepts track_id, different tracks produce different keys
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/01-symmetric-double-programming/01-01-SUMMARY.md`
</output>
