---
phase: 03-stderr-filtering-error-classification
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/omni_agents/pipeline/retry.py
  - src/omni_agents/pipeline/__init__.py
  - tests/test_pipeline/test_retry.py
autonomous: true

must_haves:
  truths:
    - "When R script fails with survminer+tidyverse loaded, classify_error returns CODE_BUG (not false positive from 'object is masked')"
    - "classify_error('object x not found') still correctly returns CODE_BUG"
    - "classify_error with empty stderr and non-zero exit code returns UNKNOWN (graceful handling)"
    - "execute_with_retry filters stderr before all consumption points (classify_error, error messages, LLM feedback)"
    - "The 500-char truncation in NonRetriableError/MaxRetriesExceeded operates on filtered stderr"
    - "LLM retry feedback (last_error) contains filtered stderr, not raw noise"
  artifacts:
    - path: "src/omni_agents/pipeline/retry.py"
      provides: "Filtered stderr integration + fixed classify_error patterns"
      exports: ["classify_error", "execute_with_retry"]
    - path: "tests/test_pipeline/test_retry.py"
      provides: "Tests for classify_error fixes and stderr filtering integration"
      min_lines: 80
  key_links:
    - from: "src/omni_agents/pipeline/retry.py"
      to: "src/omni_agents/pipeline/stderr_filter.py"
      via: "import filter_r_stderr"
      pattern: "from omni_agents.pipeline.stderr_filter import filter_r_stderr"
    - from: "src/omni_agents/pipeline/retry.py"
      to: "DockerResult constructor"
      via: "Create new DockerResult with filtered stderr"
      pattern: "DockerResult\\("
    - from: "src/omni_agents/pipeline/__init__.py"
      to: "src/omni_agents/pipeline/stderr_filter.py"
      via: "re-export filter_r_stderr"
      pattern: "filter_r_stderr"
---

<objective>
Wire `filter_r_stderr()` into the single chokepoint in `execute_with_retry()`, fix `classify_error()` patterns to eliminate false positives, and add tests proving the end-to-end fix.

Purpose: This is the integration step that makes all 7+ stderr consumption points receive clean output. Without this, the filter function from Plan 01 exists but isn't used. This plan also fixes the root cause of ERRCLASS-01 (the `"object"` substring match).

Output: Modified `retry.py` with filtered stderr flow and context-aware classify_error patterns. Tests proving no false positives on survminer/tidyverse stderr.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stderr-filtering-error-classification/03-RESEARCH.md
@.planning/phases/03-stderr-filtering-error-classification/03-01-SUMMARY.md

# Source files to modify
@src/omni_agents/pipeline/retry.py
@src/omni_agents/pipeline/__init__.py
@src/omni_agents/models/execution.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix classify_error patterns and wire filter into execute_with_retry</name>
  <files>src/omni_agents/pipeline/retry.py, src/omni_agents/pipeline/__init__.py</files>
  <action>
**Part A: Fix classify_error() (ERRCLASS-01, ERRCLASS-02, ERRCLASS-03)**

In `src/omni_agents/pipeline/retry.py`, replace the `classify_error()` function's code_patterns section (lines 150-163). The current code uses dangerous substring matches:

```python
# CURRENT (broken):
code_patterns = [
    "object",       # FALSE POSITIVE on "The following object is masked"
    "unexpected",   # Too broad
    "error in",     # Too broad
    "could not find",  # OK but imprecise
    ...
]
if any(p in stderr_lower for p in code_patterns):
```

Replace with two separate lists -- regex patterns for context-sensitive matching, and safe substring patterns:

```python
import re  # Add to imports at top of file

# Code bugs -- retriable (syntax errors, object not found, etc.)
# FIXED: Use regex for patterns needing word boundaries/context (ERRCLASS-01, ERRCLASS-02).
# These patterns match against raw stderr (not lowercased) for case-sensitive regex.
_CODE_BUG_REGEX: list[re.Pattern[str]] = [
    re.compile(r"object\s+'[^']+'\s+not found", re.IGNORECASE),
    re.compile(r"object\s+\S+\s+not found", re.IGNORECASE),
    re.compile(r"could not find function", re.IGNORECASE),
    re.compile(r"^Error in ", re.MULTILINE),
]

# Safe substring patterns (no false-positive risk on R package noise)
_CODE_BUG_SUBSTRINGS: list[str] = [
    "na/nan/inf in foreign function call",
    "unexpected symbol",
    "unexpected string",
    "unexpected '",
    "subscript out of bounds",
    "non-numeric argument",
    "replacement has",
    "arguments imply differing number of rows",
]
```

Move these to module level (above `classify_error`), not inside the function, to avoid recompilation on every call.

Update the code_patterns check inside `classify_error()` to:

```python
if any(p.search(stderr) for p in _CODE_BUG_REGEX):
    return ErrorClassification.CODE_BUG
if any(p in stderr_lower for p in _CODE_BUG_SUBSTRINGS):
    return ErrorClassification.CODE_BUG
```

Note: `_CODE_BUG_REGEX` patterns search against `stderr` (not `stderr_lower`) because the regex patterns handle case via `re.IGNORECASE` or are intentionally case-sensitive (e.g., `^Error in `).

**Part B: Wire filter_r_stderr into execute_with_retry() (STDERR-03)**

In the `execute_with_retry()` function, immediately after the Docker execution line (after `docker_result: DockerResult = await asyncio.to_thread(...)` around line 249), add:

```python
from omni_agents.pipeline.stderr_filter import filter_r_stderr

# Filter R package loading noise before any stderr consumption (STDERR-03).
# Creates a new DockerResult since Pydantic models are immutable.
docker_result = DockerResult(
    exit_code=docker_result.exit_code,
    stdout=docker_result.stdout,
    stderr=filter_r_stderr(docker_result.stderr),
    duration_seconds=docker_result.duration_seconds,
    timed_out=docker_result.timed_out,
)
```

Place the import at the top of the file with other imports (not inline). The `DockerResult` import already exists.

This single insertion point ensures ALL downstream consumers get filtered stderr:
- `_is_real_error(docker_result.stderr)` -- line 255
- `classify_error(docker_result.stderr, ...)` -- line 270
- `docker_result.stderr[:500]` in NonRetriableError -- line 286
- `last_error = docker_result.stderr` (LLM feedback) -- line 292
- `attempts[-1].docker_result.stderr[:500]` in MaxRetriesExceeded -- line 296
- And via AgentAttempt.docker_result: logging, orchestrator recording, display callbacks

**Part C: Update __init__.py exports**

In `src/omni_agents/pipeline/__init__.py`, add `filter_r_stderr` to the imports from `stderr_filter` and to `__all__`:

```python
from omni_agents.pipeline.stderr_filter import filter_r_stderr
```

Add `"filter_r_stderr"` to the `__all__` list in alphabetical position.
  </action>
  <verify>
`python -m mypy src/omni_agents/pipeline/retry.py --strict` -- no type errors.
`python -c "from omni_agents.pipeline import filter_r_stderr; print('OK')"` -- import works.
`python -m pytest tests/ -v` -- existing tests still pass (no regressions).
  </verify>
  <done>
classify_error uses context-aware regex for "object" (matches "object 'x' not found" but NOT "object is masked"). execute_with_retry filters stderr at the single chokepoint before all consumption. filter_r_stderr is exported from pipeline __init__.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for classify_error fixes and filtered retry flow</name>
  <files>tests/test_pipeline/test_retry.py</files>
  <action>
Create `tests/test_pipeline/test_retry.py` with tests proving the classify_error fixes and the end-to-end filtering integration. There are currently NO tests for retry.py -- this creates the first ones.

**Section 1: classify_error tests (ERRCLASS-01, ERRCLASS-02, ERRCLASS-03)**

```python
from omni_agents.models.execution import ErrorClassification
from omni_agents.pipeline.retry import classify_error
```

Test cases:

1. `test_classify_object_not_found_is_code_bug` -- `classify_error("Error in eval(expr, envir, enclos) : object 'nonexistent_var' not found", 1, False)` returns `CODE_BUG`.

2. `test_classify_object_masked_not_code_bug` -- CRITICAL test for ERRCLASS-01. Input: just the "The following object is masked from 'package:survival':\n\n    myeloma" text (no actual error). With exit_code=0, timed_out=False. Should return `UNKNOWN` (not CODE_BUG). This verifies the "object" false positive is fixed.

3. `test_classify_could_not_find_function` -- `classify_error("Error in library(nonexistent) : could not find function 'foo'", 1, False)` returns `CODE_BUG`.

4. `test_classify_unexpected_symbol` -- `classify_error("Error: unexpected symbol in ...", 1, False)` returns `CODE_BUG`.

5. `test_classify_error_in_line_start` -- `classify_error("Error in foo() : bar", 1, False)` returns `CODE_BUG` (matches `^Error in `).

6. `test_classify_environment_error` -- `classify_error("there is no package called 'nonexistent'", 1, False)` returns `ENVIRONMENT_ERROR`.

7. `test_classify_timeout` -- `classify_error("", 1, True)` returns `TIMEOUT`.

8. `test_classify_empty_stderr_unknown` -- `classify_error("", 1, False)` returns `UNKNOWN`. Verifies graceful handling of empty stderr.

9. `test_classify_data_path_error` -- `classify_error("cannot open connection to '/data/missing.csv'", 1, False)` returns `DATA_PATH_ERROR`.

10. `test_classify_statistical_error` -- `classify_error("Error in solve.default(t(x) %*% x) : system is computationally singular", 1, False)` returns `STATISTICAL_ERROR`.

**Section 2: End-to-end integration test (STDERR-03, ERRDSP-01, ERRDSP-02)**

Test that `filter_r_stderr` + `classify_error` together produce correct results on realistic input:

11. `test_filtered_survminer_tidyverse_classified_correctly` -- Use the FULL combined stderr sample from RESEARCH.md (survminer + tidyverse + "Error in readRDS(con)"). First filter it with `filter_r_stderr()`, then classify with `classify_error()`. Result should be `CODE_BUG` (from "Error in readRDS"), NOT because of "object".

12. `test_filtered_stderr_fits_truncation_window` -- Same full stderr sample. After `filter_r_stderr()`, verify `len(result) < 500` (the truncation window). This proves ERRDSP-02: the 500-char window now contains the real error.

13. `test_all_noise_no_error_classified_unknown` -- Input: ONLY noise (tidyverse banner, no actual error). After filtering, stderr is empty. `classify_error("", 0, False)` returns `UNKNOWN`.

Import `filter_r_stderr` from `omni_agents.pipeline.stderr_filter` for integration tests.

Use the same realistic stderr constant from `test_stderr_filter.py` (copy or define a module-level constant -- don't import from the other test file to keep tests independent).

Run: `cd /Users/sanmaysarada/omni-ai-agents && python -m pytest tests/test_pipeline/test_retry.py -v`
  </action>
  <verify>
`python -m pytest tests/test_pipeline/test_retry.py -v` -- all tests pass.
`python -m pytest tests/ -v` -- full test suite passes (no regressions from any plan).
  </verify>
  <done>
classify_error correctly classifies "object 'x' not found" as CODE_BUG while NOT false-matching "object is masked". Integration test proves that filtered survminer+tidyverse stderr is correctly classified and fits within the 500-char truncation window. All 13+ tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_pipeline/test_stderr_filter.py tests/test_pipeline/test_retry.py -v` -- all filter + classify tests pass
2. `python -m mypy src/omni_agents/pipeline/retry.py src/omni_agents/pipeline/stderr_filter.py --strict` -- clean type checking
3. `python -m pytest tests/ -v` -- full suite passes, no regressions
4. Manual verification: the "object" substring match no longer exists in classify_error code_patterns
5. Manual verification: filter_r_stderr is called in execute_with_retry before _is_real_error, classify_error, and all error message construction
</verification>

<success_criteria>
- classify_error("The following object is masked from 'package:survival':\n\n    myeloma", 0, False) returns UNKNOWN (not CODE_BUG) -- ERRCLASS-01 fixed
- classify_error("object 'x' not found", 1, False) returns CODE_BUG -- real errors still detected
- execute_with_retry creates a new DockerResult with filtered stderr before any consumption -- STDERR-03 satisfied
- filter_r_stderr is imported and called exactly once at the chokepoint -- single filtering point
- Full stderr sample from survminer+tidyverse+error filters to just the error line, which fits in 500 chars -- ERRDSP-01, ERRDSP-02 satisfied
- LLM retry feedback (last_error) will contain filtered stderr -- requirement 3 of phase success criteria
- All tests pass, mypy passes, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-stderr-filtering-error-classification/03-02-SUMMARY.md`
</output>
