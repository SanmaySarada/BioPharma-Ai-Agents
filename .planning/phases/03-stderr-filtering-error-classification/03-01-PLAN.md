---
phase: 03-stderr-filtering-error-classification
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/omni_agents/pipeline/stderr_filter.py
  - tests/test_pipeline/test_stderr_filter.py
autonomous: true

must_haves:
  truths:
    - "filter_r_stderr('') returns ''"
    - "filter_r_stderr strips tidyverse banner, conflict lines, checkmark lines, info lines"
    - "filter_r_stderr strips survminer loading messages (Loading required package, Attaching package, masked object lines, indented continuation)"
    - "filter_r_stderr preserves lines starting with Error or error unconditionally"
    - "filter_r_stderr preserves legitimate R warnings (e.g., 'Warning: NAs introduced by coercion')"
    - "filter_r_stderr returns only the real error when given a full survminer+tidyverse stderr blob with an actual error"
    - "Filtered output has no leading/trailing blank lines"
  artifacts:
    - path: "src/omni_agents/pipeline/stderr_filter.py"
      provides: "filter_r_stderr() function and _NOISE_PATTERNS constant"
      exports: ["filter_r_stderr"]
    - path: "tests/test_pipeline/test_stderr_filter.py"
      provides: "Comprehensive tests for filter_r_stderr"
      min_lines: 100
  key_links:
    - from: "tests/test_pipeline/test_stderr_filter.py"
      to: "src/omni_agents/pipeline/stderr_filter.py"
      via: "import filter_r_stderr"
      pattern: "from omni_agents.pipeline.stderr_filter import filter_r_stderr"
---

<objective>
Create the `filter_r_stderr()` function using TDD: write failing tests first with real R stderr samples, then implement the filtering function to pass them.

Purpose: This is the core filtering logic that all downstream stderr consumers depend on. TDD ensures correctness against real-world R stderr patterns -- particularly the tricky "object is masked" false positive and Unicode tidyverse output.

Output: A tested, working `filter_r_stderr()` function in a new `stderr_filter.py` module, ready to be wired into `execute_with_retry()` in Plan 02.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stderr-filtering-error-classification/03-RESEARCH.md

# Source files for understanding existing patterns
@src/omni_agents/pipeline/retry.py
@src/omni_agents/models/execution.py
@tests/test_pipeline/test_resolution.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Write failing tests for filter_r_stderr</name>
  <files>tests/test_pipeline/test_stderr_filter.py</files>
  <action>
Create `tests/test_pipeline/test_stderr_filter.py` with comprehensive tests for `filter_r_stderr()`. Import from `omni_agents.pipeline.stderr_filter` (module does not exist yet -- tests MUST fail).

Also create the minimal stub `src/omni_agents/pipeline/stderr_filter.py` containing ONLY:

```python
def filter_r_stderr(stderr: str) -> str:
    return stderr  # Stub -- tests should fail
```

This stub allows tests to import but not pass (proper RED state).

**Test cases to write (each as its own test function):**

1. `test_empty_string_returns_empty` -- `filter_r_stderr("")` returns `""`
2. `test_none_passthrough` -- `filter_r_stderr("")` returns `""` (empty string, since function takes str)
3. `test_pure_error_preserved` -- Input: `"Error in eval(expr) : object 'x' not found"` -> same output unchanged
4. `test_tidyverse_banner_stripped` -- Input: full tidyverse banner (use the exact Unicode sample from RESEARCH.md lines 450-459 including box-drawing chars U+2500, checkmarks U+2714, cross U+2716, info U+2139). Output: empty string.
5. `test_survminer_loading_stripped` -- Input: survminer loading block (RESEARCH.md lines 464-471: "Loading required package: ggplot2", "Loading required package: ggpubr", "Attaching package: 'survminer'", "The following object is masked from 'package:survival':", "    myeloma"). Output: empty string.
6. `test_dplyr_masked_objects_stripped` -- Input: dplyr loading block (RESEARCH.md lines 475-482: Attaching package: 'dplyr', masked objects from stats, indented "filter, lag", masked from base, indented "intersect, setdiff, setequal, union"). Output: empty string.
7. `test_real_error_with_survminer_tidyverse_noise` -- Input: the FULL combined stderr sample from RESEARCH.md lines 364-383 (survminer + tidyverse loading + "Error in readRDS(con) : error reading from connection"). Output: ONLY `"Error in readRDS(con) : error reading from connection"`. Assert "myeloma" not in result, "Attaching" not in result, "masks" not in result.
8. `test_legitimate_warning_preserved` -- Input: `"Warning: NAs introduced by coercion"`. Output: same string unchanged.
9. `test_legitimate_warning_in_sqrt_preserved` -- Input: `"Warning message:\nIn sqrt(x) : NaNs produced"`. Output: same string unchanged. (Note: "Warning message:" alone could match a noise pattern -- but it should NOT be filtered when followed by a real warning. However, per RESEARCH.md, bare "Warning message:" IS a noise pattern for package loading. The key distinction: if the ONLY content after filtering would be empty, that's fine. But "In sqrt(x) : NaNs produced" should always be preserved. Implement test as: assert `"In sqrt(x) : NaNs produced"` is in the result.)
10. `test_registered_s3_stripped` -- Input: `"Registered S3 method overwritten by 'ggplot2':\n  method      from\n  print.ggproto"`. The first line should be stripped. The indented continuation lines should also be stripped.
11. `test_mixed_noise_and_multiple_errors` -- Input: some noise lines + `"Error in foo() : bar\nWarning: baz"`. Output preserves both the Error line and the Warning line.
12. `test_leading_trailing_blank_lines_stripped` -- Input with blank lines around an error. Output has no leading/trailing blanks.
13. `test_error_lines_never_filtered` -- Safety net: any line starting with "Error" must survive regardless of content. Input: `"Error in loading package: test"` (contains "loading package" which looks like noise). Output: preserved.

Use module-level constants for the large stderr samples to keep tests readable. Follow the project's test style (plain pytest functions or classes, no fixtures needed).

Run tests: `cd /Users/sanmaysarada/omni-ai-agents && python -m pytest tests/test_pipeline/test_stderr_filter.py -v`

Tests MUST fail (the stub returns input unchanged, so tests checking that noise is stripped will fail). Commit the failing tests.
  </action>
  <verify>
`python -m pytest tests/test_pipeline/test_stderr_filter.py -v` runs and the majority of tests FAIL (specifically: tests 4-7, 10, 12 should fail because the stub doesn't filter anything). Tests 1, 3, 8, 11, 13 may pass (input equals output for those). This confirms proper RED state.
  </verify>
  <done>Test file exists with 12+ test cases covering all R noise patterns, legitimate warnings, error preservation, and edge cases. Tests are importable and runnable. Most tests fail against the stub.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Implement filter_r_stderr to pass all tests</name>
  <files>src/omni_agents/pipeline/stderr_filter.py</files>
  <action>
Replace the stub in `src/omni_agents/pipeline/stderr_filter.py` with the full implementation. Follow the implementation pattern from RESEARCH.md (Pattern 2, lines 77-124 and the complete example at lines 211-288) with these specifics:

1. Module docstring explaining purpose (strip R package loading noise, applied once in execute_with_retry).

2. `_NOISE_PATTERNS: tuple[re.Pattern[str], ...]` -- a module-level tuple of compiled regex patterns. Include ALL patterns from RESEARCH.md lines 225-252:
   - tidyverse banner line: `Attaching (core )?tidyverse packages?`
   - Conflicts header: `Conflicts\s*[\u2500-\u257f-]+`
   - Package conflict: `\w+::\w+\(\)\s+masks\s+\w+::\w+\(\)`
   - Object masking header: `The following objects?\s+(is|are)\s+masked\s+from`
   - Loading required package: `^Loading required package:\s`
   - Attaching package: `^Attaching package:\s`
   - Checkmark/bullet lines: `^[\u2714\u2716\u2713\u2717\u2022\u2139]`
   - Conflicted package info: `Use the conflicted package`
   - Registered S3 method: `^Registered S3 method`
   - Indented continuation: `^\s{4,}[\w.,\s]+$`
   - Also loading: `^also loading:`
   - Box-drawing decoration: `^[\u2500-\u257f\s-]+$`
   - Replacing previous import: `replacing previous import`

3. `filter_r_stderr(stderr: str) -> str` function:
   - Early return empty string for empty/falsy input
   - Split into lines, iterate
   - Safety net: lines starting with "Error" or "error" are NEVER filtered (append and continue)
   - Check each line against `_NOISE_PATTERNS` with `any(p.search(line) for p in _NOISE_PATTERNS)`
   - If no pattern matches, keep the line
   - Join filtered lines, strip leading/trailing whitespace
   - Return result

4. Type hints throughout. Use `import re` from stdlib only.

Run tests: `cd /Users/sanmaysarada/omni-ai-agents && python -m pytest tests/test_pipeline/test_stderr_filter.py -v`

ALL tests must pass. If any fail, iterate on the implementation until green. Do NOT modify tests to make them pass -- fix the implementation.

Once green, also run type checking: `cd /Users/sanmaysarada/omni-ai-agents && python -m mypy src/omni_agents/pipeline/stderr_filter.py --strict`

Commit the passing implementation.
  </action>
  <verify>
`python -m pytest tests/test_pipeline/test_stderr_filter.py -v` -- ALL tests pass (0 failures).
`python -m mypy src/omni_agents/pipeline/stderr_filter.py --strict` -- no errors.
  </verify>
  <done>filter_r_stderr() correctly strips all R package loading noise patterns while preserving real errors and legitimate warnings. All tests pass. Type checking passes.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_pipeline/test_stderr_filter.py -v` -- all tests pass
2. `python -m mypy src/omni_agents/pipeline/stderr_filter.py --strict` -- clean
3. `python -m pytest tests/ -v` -- full test suite still passes (no regressions)
</verification>

<success_criteria>
- filter_r_stderr("") returns ""
- filter_r_stderr strips all 13 noise pattern categories from RESEARCH.md
- filter_r_stderr preserves lines starting with "Error"/"error" unconditionally
- filter_r_stderr preserves legitimate R warnings
- Real survminer+tidyverse stderr with error reduces to just the error line
- All tests pass, mypy strict passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-stderr-filtering-error-classification/03-01-SUMMARY.md`
</output>
